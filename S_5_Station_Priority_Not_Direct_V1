import numpy as np
import pandas as pd
from collections import Counter

# === Configuration globale ===
class Config:
    N_STATIONS = 7
    TRAM_CAPACITY = 50
    SIM_DURATION = 900   # dur√©e totale (minutes)
    TIME_STEP = 1
    STOP_DURATION = 3
    N_TRAMS = 1  # <-- changer ici le nombre de tramways

# === Matrice des temps de trajet entre stations (minutes) ===
travel_time = np.array([
    [  0,  10,  20,  35,  50,  60,  75],
    [ 10,   0,  10,  25,  40,  50,  65],
    [ 20,  10,   0,  15,  30,  40,  55],
    [ 35,  25,  15,   0,  15,  25,  40],
    [ 50,  40,  30,  15,   0,  10,  25],
    [ 60,  50,  40,  25,  10,   0,  15],
    [ 75,  65,  55,  40,  25,  15,   0],
])

# === Classe pour mod√©liser une demande de transport ===
class TransportRequest:
    def __init__(self, req_type, departure, arrival, creation_time, hide_time, arrival_deadline=None):
        self.type = req_type
        self.departure = int(departure)
        self.arrival = int(arrival)
        self.time = int(creation_time)
        self.hide_time = int(hide_time)
        self.deadline = int(arrival_deadline) if arrival_deadline is not None else None
        self.status = "waiting"
        self.arrived_time = None
        self.delivered_late = False
        self.expected_arrival_time = None  # üÜï Temps de livraison pr√©vu
        self.delay = None  # üÜï Retard r√©el (si applicable)

# === Structure globale pour g√©rer les tron√ßons occup√©s ===
active_segments = {}  # cl√© = (station_start, station_end), valeur = tram_id

# === Classe mod√©lisant un tramway autonome ===
class Tram:
    def __init__(self, tram_id):
        self.id = tram_id
        self.position = 0
        self.capacity = Config.TRAM_CAPACITY
        self.passengers = []
        self.route = []
        self.next_station = None
        self.remaining_time = 0
        self.waiting_time = 0

    # D√©poser les passagers arriv√©s
    def drop_off(self, current_time):
        served = [p for p in self.passengers if p.arrival == self.position]
        for r in served:
            r.status = "served"
            r.arrived_time = current_time
            if r.expected_arrival_time is not None:
                r.delay = r.arrived_time - r.expected_arrival_time
            if r.deadline is not None:
                r.delivered_late = (r.arrived_time > r.deadline)
        self.passengers = [p for p in self.passengers if p.arrival != self.position]
        return served

    # Embarquer les demandes pr√©sentes √† la station
    def pick_up(self, waiting_list, current_time):
        onboarded = []
        remaining = []
        for r in waiting_list:
            if (len(self.passengers) < self.capacity
                and r.departure == self.position
                and r.status == "waiting"
                and r.time <= current_time):
                r.status = "onboard"
                r.expected_arrival_time = current_time + travel_time[self.position, r.arrival]  # üÜï Pr√©vision
                onboarded.append(r)
                self.passengers.append(r)
            else:
                remaining.append(r)
        return onboarded, remaining

    # D√©cider la prochaine station selon logique autonome
    def decide_route(self, waiting_requests):
        if self.passengers:
            destinations = [p.arrival for p in self.passengers]
            next_station = min(destinations, key=lambda s: abs(s - self.position))
        else:
            scores = [(s, sum(1 for r in waiting_requests if r.departure == s and r.status == "waiting"))
                      for s in range(Config.N_STATIONS) if s != self.position]
            if scores:
                next_station = max(scores, key=lambda x: x[1])[0]
            else:
                next_station = self.position

        if next_station > self.position:
            self.route = list(range(self.position + 1, next_station + 1))
        elif next_station < self.position:
            self.route = list(range(self.position - 1, next_station - 1, -1))
        else:
            self.route = []

    # D√©placer vers la prochaine station avec v√©rification du tron√ßon
    def move_to_next_station(self):
        global active_segments
        if self.route:
            proposed_next = self.route[0]
            segment = (self.position, proposed_next)
            reverse_segment = (proposed_next, self.position)

            # V√©rifier qu'aucun tram ne circule dans le sens oppos√©
            if reverse_segment not in active_segments:
                self.next_station = self.route.pop(0)
                self.remaining_time = travel_time[self.position, self.next_station]
                active_segments[segment] = self.id
            else:
                # Tron√ßon occup√© par un tram en sens inverse : attendre
                self.next_station = None
                self.remaining_time = 0

    # Compl√©ter le mouvement et lib√©rer le tron√ßon
    def complete_move(self):
        global active_segments
        if self.next_station is not None:
            segment = (self.position, self.next_station)
            self.position = self.next_station
            self.next_station = None
            if segment in active_segments:
                del active_segments[segment]

# === Chargement des demandes depuis CSV ===
df = pd.read_csv("demandes_2A_0.csv")
all_requests = []
for _, row in df.iterrows():
    arrival_deadline = row.get('arrival_deadline') if 'arrival_deadline' in row.index else None
    req = TransportRequest(
        row['type'],
        int(row['departure']),
        int(row['arrival']),
        int(row['creation_time']),
        int(row['hide_time']),
        arrival_deadline
    )
    all_requests.append(req)

# V√©rification de validit√© des demandes
invalid_requests = [r for r in all_requests if r.departure < 0 or r.departure >= Config.N_STATIONS
                    or r.arrival < 0 or r.arrival >= Config.N_STATIONS]
if invalid_requests:
    print("Attention : Certaines demandes ont des stations invalides !")

# === Initialisation de la simulation ===
trams = [Tram(i) for i in range(Config.N_TRAMS)]
time = 0
waiting_requests = []
future_requests = sorted(all_requests, key=lambda r: r.time)
served_requests = []

# === Boucle principale de simulation ===
while time < Config.SIM_DURATION:
    # Activer nouvelles demandes
    new_requests = [r for r in future_requests if r.time == time]
    if new_requests:
        waiting_requests.extend(new_requests)
        future_requests = [r for r in future_requests if r.time > time]

    # Gestion hide_time
    for r in waiting_requests:
        if r.status == "waiting" and time > r.hide_time:
            r.status = "lost"

    # Mise √† jour des tramways
    for tram in trams:
        if tram.remaining_time > 0:
            tram.remaining_time -= Config.TIME_STEP
            if tram.remaining_time <= 0:
                tram.complete_move()
                served = tram.drop_off(time)
                served_requests.extend(served)
                onboarded, waiting_requests = tram.pick_up(waiting_requests, time)
                waiting_requests = [r for r in waiting_requests if r.status == "waiting"]
                tram.waiting_time = Config.STOP_DURATION

        elif tram.waiting_time > 0:
            tram.waiting_time -= Config.TIME_STEP
            if tram.waiting_time <= 0:
                if not tram.route:
                    tram.decide_route(waiting_requests)
                tram.move_to_next_station()

        elif not tram.route:
            tram.decide_route(waiting_requests)
            tram.move_to_next_station()

    time += Config.TIME_STEP

# --- Traiter unit√©s √† bord comme perdues ---
for tram in trams:
    for r in tram.passengers:
        if r.status == "onboard":
            r.status = "lost"
    tram.passengers = []

# === Bilan final ===
final_status = Counter(req.status for req in all_requests)
logistic_units_served_on_time = sum(1 for r in all_requests if r.type == "logistic_unit" and r.status == "served" and not r.delivered_late)
logistic_units_late = sum(1 for r in all_requests if r.type == "logistic_unit" and r.status == "served" and r.delivered_late)
logistic_units_lost = sum(1 for r in all_requests if r.type == "logistic_unit" and r.status == "lost")

delays = [r.delay for r in all_requests if r.delay is not None]
avg_delay = np.mean(delays) if delays else 0

print(f"\n=== Bilan final pour {len(all_requests)} demandes ===")
print(f"‚Ä¢ Logistic_units servis √† l'heure: {logistic_units_served_on_time}")
print(f"‚Ä¢ Logistic_units servis en retard: {logistic_units_late}")
print(f"‚Ä¢ Logistic_units perdus:           {logistic_units_lost}")
print(f"‚Ä¢ D√©lai moyen (min):              {avg_delay:.2f}")
