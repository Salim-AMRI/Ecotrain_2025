import numpy as np
import matplotlib.pyplot as plt
from matplotlib.animation import FuncAnimation
from IPython.display import HTML, display
import pandas as pd
from collections import Counter

# === Configuration ===
class Config:
    N_STATIONS = 6
    TRAM_CAPACITY = 50
    SIM_DURATION = 330        # Durée totale simulation en minutes
    TIME_STEP = 1             # Pas de temps en minutes (granularité)
    STOP_DURATION = 3
    VISIBILITY_HORIZON = 150  # Horizon de visibilité (minutes)
    MAX_WAIT_TIME = 15        # Temps max d'attente avant disparition (minutes)

# === Matrice travel_time ===
travel_time = np.array([
    [0,  5, 10, 15, 20, 25],
    [5,  0,  5, 10, 15, 20],
    [10, 5,  0,  5, 10, 15],
    [15,10, 5,  0,  5, 10],
    [20,15,10, 5,  0,  5],
    [25,20,15,10, 5,  0]
])

# === Classe TransportRequest ===
class TransportRequest:
    def __init__(self, req_type, departure, arrival, time):
        self.type = req_type
        self.departure = departure
        self.arrival = arrival
        self.time = time              # Temps d'apparition
        self.deadline = None          # Date limite prise en charge
        self.arr_time = None          # Arrivée prévue
        self.arr_deadline = None      # Date limite arrivée
        self.status = "waiting"       # waiting, onboard, served_on_time, served_late, lost

    def is_expired(self, current_time):
        # Expiré si temps actuel > temps apparition + MAX_WAIT_TIME
        return current_time > self.time + Config.MAX_WAIT_TIME

    def is_late(self, current_time):
        # Retard à la livraison pour colis
        return self.type == "parcel" and current_time > self.arr_deadline

# === Chargement des demandes depuis CSV ===
def load_requests(csv_file):
    df = pd.read_csv(csv_file)
    requests = []
    for _, row in df.iterrows():
        req = TransportRequest(
            row['type'],
            int(row['departure']),
            int(row['arrival']),
            int(row['creation_time'])
        )
        req.deadline = int(row['deadline'])
        req.arr_time = int(row['predicted_arrival'])
        req.arr_deadline = int(row['arrival_deadline'])
        requests.append(req)
    return requests

all_requests = load_requests('D_5.csv')
Config.SIM_DURATION = max(req.arr_deadline for req in all_requests) + 20

# === Initialisation des structures ===
stations = [[] for _ in range(Config.N_STATIONS)]
station_stats = {i: {'served':0, 'lost':0, 'late':0} for i in range(Config.N_STATIONS)}

tram = {
    "position": 0,
    "onboard": [],
    "capacity": Config.TRAM_CAPACITY,
    "stop_timer": 0,
    "direction": 1  # pour conserver un sens si besoin
}

stats = {
    "passengers": {"total":0, "served":0, "lost":0},
    "parcels":    {"total":0, "served":0, "lost":0, "late":0},
    "status": Counter()
}

time_stats = {
    "time": [],
    "passengers": {"total":[], "served":[], "lost":[]},
    "parcels":    {"total":[], "served":[], "lost":[], "late":[]},
    "occupation": []
}

# === Vérification globale des demandes expirées ===
def check_expired_requests(current_time):
    for station_id in range(Config.N_STATIONS):
        station_queue = stations[station_id]
        new_queue = []
        for req in station_queue:
            if req.status == "waiting" and req.is_expired(current_time):
                req.status = "lost"
                stats[f"{req.type}s"]["lost"] += 1
                station_stats[station_id]["lost"] += 1
            else:
                new_queue.append(req)
        stations[station_id] = new_queue

# === Fonction de scoring des stations ===
def compute_station_score(station_id, current_time, tram_capacity, stations, all_requests, horizon):
    score = 0
    for req in stations[station_id]:
        if req.status == "waiting" and not req.is_expired(current_time):
            size = 1 if req.type=="passenger" else 0.5
            if tram_capacity >= size:
                score += size
    for req in all_requests:
        if (req.departure == station_id
            and current_time < req.time <= current_time+horizon
            and req.status=="waiting"):
            size = 1 if req.type=="passenger" else 0.5
            if tram_capacity >= size:
                score += size
    return score

# === Choix de la prochaine station ===
def choose_next_station(tram_pos, current_time, tram_capacity, stations, all_requests, horizon):
    # Priorité : débarquer les unités à bord
    onboard_dest = {req.arrival for req in tram["onboard"] if req.status=="onboard"}
    if onboard_dest:
        return min(onboard_dest, key=lambda s: abs(s-tram_pos))
    # Sinon, station avec meilleur score
    best = (0, tram_pos)
    for s in range(Config.N_STATIONS):
        if s == tram_pos:
            continue
        sc = compute_station_score(s, current_time, tram_capacity, stations, all_requests, horizon)
        if sc > best[0]:
            best = (sc, s)
    return best[1] if best[0] > 0 else tram_pos

# === Fonction update ===
def update(frame):
    current_time = frame * Config.TIME_STEP
    title.set_text(f"Temps : {current_time} min")
    time_stats["time"].append(current_time)

    # Arrivée des nouvelles demandes (apparition)
    for req in all_requests:
        if req.time == current_time:
            stations[req.departure].append(req)
            key = "passengers" if req.type=="passenger" else "parcels"
            stats[key]["total"] += 1

    # Vérification GLOBALE des demandes expirées
    check_expired_requests(current_time)

    pos = tram["position"]

    # Décrément timer arrêt tram
    if tram["stop_timer"] > 0:
        tram["stop_timer"] -= 1
    else:
        # 1. Débarquement immédiat des unités arrivées
        remaining = []
        for req in tram["onboard"]:
            if req.arrival == pos:
                if req.is_late(current_time):
                    req.status = "served_late"
                    stats["parcels"]["late"] += 1
                    station_stats[pos]["late"] += 1
                else:
                    req.status = "served_on_time"
                    stats[f"{req.type}s"]["served"] += 1
                    station_stats[pos]["served"] += 1
                tram["capacity"] += (1 if req.type=="passenger" else 0.5)
                tram["stop_timer"] += Config.STOP_DURATION
            else:
                remaining.append(req)
        tram["onboard"] = remaining

        # 2. Embarquement des demandes en attente
        # (les expirées ont déjà été traitées par check_expired_requests)
        new_queue = []
        for req in stations[pos]:
            if req.status != "waiting":
                continue
            size = 1 if req.type == "passenger" else 0.5
            # Vérification qu’on respecte les délais pour les unités déjà à bord
            feasible = True
            for ob in tram["onboard"]:
                travel = abs(ob.arrival - pos)
                if current_time + travel > ob.arr_deadline:
                    feasible = False
                    break
            if feasible and tram["capacity"] >= size:
                req.status = "onboard"
                tram["onboard"].append(req)
                tram["capacity"] -= size
                tram["stop_timer"] += Config.STOP_DURATION
            else:
                new_queue.append(req)
        stations[pos] = new_queue

        # 3. Déplacement vers prochaine station
        if tram["stop_timer"] == 0:
            next_st = choose_next_station(
                tram_pos=pos,
                current_time=current_time,
                tram_capacity=tram["capacity"],
                stations=stations,
                all_requests=all_requests,
                horizon=Config.VISIBILITY_HORIZON
            )
            tram["direction"] = 1 if next_st > pos else -1
            tram["position"] = next_st

    # 4. Mise à jour des statistiques temporelles
    for key in ["passengers", "parcels"]:
        for sub in ["total", "served", "lost"]:
            time_stats[key][sub].append(stats[key][sub])
    time_stats["parcels"]["late"].append(stats["parcels"]["late"])
    time_stats["occupation"].append(len(tram["onboard"]) / Config.TRAM_CAPACITY)

    # 5. Mise à jour graphique
    tram_marker.set_data([tram["position"]], [0.2])
    for i, txt in enumerate(text_annotations):
        s = station_stats[i]["served"]
        l = station_stats[i]["lost"]
        la = station_stats[i]["late"]
        txt.set_text(f"S:{s}\nL:{l}\nT:{la}")

    return [tram_marker, *text_annotations, title]

# === Préparation animation ===
fig, ax = plt.subplots(figsize=(12,4))
ax.set_xlim(-1, Config.N_STATIONS)
ax.set_ylim(-0.5, 1.5)
ax.set_yticks([])
ax.plot(range(Config.N_STATIONS), [0]*Config.N_STATIONS, 'ko', markersize=10)
tram_marker = ax.plot([], [], 'rs', markersize=15)[0]
text_annotations = [ax.text(i, 0.5, "", ha='center') for i in range(Config.N_STATIONS)]
title = ax.text(0.5, 1.5, "", ha='center', va='center', transform=ax.transAxes)

ani = FuncAnimation(
    fig, update,
    frames=Config.SIM_DURATION // Config.TIME_STEP,
    blit=True, interval=200
)
display(HTML(ani.to_jshtml()))

# === Bilan final ===
final_status = Counter(req.status for req in all_requests)
print(f"\n=== Bilan final pour {len(all_requests)} demandes ===")
print(f"• Passagers satisfaits: {stats['passengers']['served']}")
print(f"• Passagers perdus:    {stats['passengers']['lost']}\n")
print(f"• Colis servis à l'heure: {stats['parcels']['served']}")
print(f"• Colis servis en retard: {stats['parcels']['late']}")
print(f"• Colis perdus:           {stats['parcels']['lost']}\n")
print(f"• En attente: {final_status.get('waiting', 0)}")
print(f"• À bord:     {final_status.get('onboard', 0)}")

# === Visualisation des statistiques ===
fig2, ax2 = plt.subplots(3, 1, figsize=(10,8), sharex=True)
ax2[0].plot(time_stats["time"], time_stats["passengers"]["served"], label='Passagers servis')
ax2[0].plot(time_stats["time"], time_stats["passengers"]["lost"], label='Passagers perdus')
ax2[0].set_ylabel("Passagers")
ax2[0].legend()
ax2[1].plot(time_stats["time"], time_stats["parcels"]["served"], label='Colis servis')
ax2[1].plot(time_stats["time"], time_stats["parcels"]["lost"], label='Colis perdus')
ax2[1].plot(time_stats["time"], time_stats["parcels"]["late"], label='Colis retard')
ax2[1].set_ylabel("Colis")
ax2[1].legend()
ax2[2].plot(time_stats["time"], time_stats["occupation"], label='Occupation tram')
ax2[2].set_ylabel("Occupation (%)")
ax2[2].set_xlabel("Temps (min)")
ax2[2].legend()
plt.tight_layout()
plt.show()
